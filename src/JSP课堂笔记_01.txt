JSP
=================================================<!+>
一.JSP概述
	---------------------------------------------
	1.1.jsp介绍
		由SUN公司提供的动态web资源的开发技术, 看起来非常像html, 但是可以在JSP页面中写java代码, 所以JSP是一种动态web资源开发技术.
		
	---------------------------------------------<!+>
	1.2.JSP的出现是为了解决Servlet在响应时不适合向外输出页面的问题
		Servlet本质上是一段java代码, 非常适合处理逻辑, 但是不合适向外输出页面。
		
		HTML适合用来开发页面, 展示数据, 但是HTML开发出来的页面本质上就是一个文档, 无法展示动态的数据。

		JSP非常适合编写HTML代码, 适合作为响应页面向外输出, 同时JSP里可以写java代码, 也可以展示动态的数据。
		所以JSP可以解决既要处理逻辑又要向外输出页面的难题。

	---------------------------------------------
	1.3.JSP在第一次访问时, 会被翻译成一个Servlet, 对JSP访问后看到的页面 其实就是翻译后的Servlet在向外输出！！
	
=================================================<!->

二.JSP语法
	---------------------------------------------
	2.1.模版元素:  html代码 
		◇ 直接写在jsp页面中的html内容称之为jsp页面中的模版元素
		◇ 模版元素在翻译过来的Servlet中被out.write()原样输出到浏览器中
			out.write("\tday13....index.jsp........\r\n");

	---------------------------------------------
	2.2.JSP表达式: 
		<%= 脚本表达式 %>  常量 变量 表达式
		◇ 在翻译过来的Servlet中, 计算表达式的值原样输出
			out.print( 100+123 );
			
	---------------------------------------------
	2.3.JSP脚本片段: <% 若干java语句 %> Scriptlet
		◇ 在翻译过来的servlet中, 脚本片段被复制粘贴到对应位置执行
		翻译前:
			<% for(int i=0; i<5; i++){ %>
				Hello JSP~~~~~<br/>
			<% } %>
		翻译后: 
			for(int i=0; i<5; i++){ 
			      out.write("\r\n");
			      out.write("\t\tHello JSP~~~~~<br/>\r\n");
			      out.write("\t");
			} 
		
		◇ 多个脚本片段之间的变量可以互相访问
		◇ 在某一个脚本片段中的java代码可以是不完整的, 但是要求在翻译过来的servlet中整体的代码必须是完整符合java语法的
		◇ 任何文本，HTML标记，JSP元素必须在脚本片段之外 

	---------------------------------------------
	~~2.4.JSP声明:(不常用)
		格式: <%! java代码 %>
			◇ 写在jsp声明中的内容, 在翻译过来的servlet中会和servlet方法平级成为类的成员
			( 注意: 写在JSP脚本片段中的内容, 在翻译过来的servlet中是方法的局部变量! )

	---------------------------------------------
	2.5.JSP注释:
		格式: <%-- JSP注释 --%>
		<%-- out.write("aaa"); --%> 被JSP注释注释的内容, 在翻译的过程中被抛弃, 不会被翻译
		
		<% //out.write("bbb"); %> 被java注释注释的内容, 在翻译的过程中被当作脚本片段翻译到servlet中, 但是由于被注释了, 所以也不会执行
		<!-- <% out.write("ccc"); %> --> 被HTML注释注释的内容, 在翻译过程中直接当作模版元素原样输出到浏览器, 但是浏览器认为是注释, 所以不予显示

		!!!在jsp中最好使用jsp注释, html注释慎用!!

	---------------------------------------------
	2.6.JSP指令:
		<%@ 指令名称 若干属性声明... %> 
			-- 不会直接产生输出, 用来指挥解析引擎如何来翻译当前JSP页面中其他部分的内容
			-------------------------------------
			2.6.1.page指令 
				-- 用来声明当前JSP页面的基本属性的, page指令可以写在JSP页面的任意位置, 但是为了可读性考虑, 一般情况下最好放在JSP页面的最前面
				格式: <%@ page ... %>

			-------------------------------------
			2.6.2.page指令属性介绍
				~~[ language="java" ] 当前JSP使用的开发语言
				
				~~[ extends="package.class" ] 当前JSP翻译成servlet后要继承的类，注意此值必须是一个servlet的子类，一般情况下不要改

				!![ import="{ package.class | package.*}, ..." ] 
					导入需要使用到的包 
					java.lang.*; 
					javax.servlet.*; 
					javax.servlet.JSP.*; javax.servlet.http.*;
						
					可以在一个page指令的import属性中导入多个包  也可以通过多个page指令来分别导包
				示例:
					<%@ page language="java" import="java.util.*,java.sql.*" pageEncoding="utf-8" isErrorPage="true"%>
					<%@ page import="java.io.*" %>
					
				![ session="true | false" ] 
					用来指定当前页面是否使用session，如果设置为true，则翻译过来的servlet中将会有对session对象的引用，于是可以直接在JSP中使用session隐式对象。但是这将导致一旦访问JSP就会调用request.getSession()方法，可能导致不必要的空间浪费。如果确定JSP中不需要session可以设为false
	
				[ errorPage="relative_url" ] 如果页面出错，将要跳转到的页面，除了在JSP中使用此属性指定错误页面外也可以在web.xml中配置整个web应用的错误页面，如果两个都设置则JSP中的此属性起作用
					<error-page>
						 <exception-type>java.lang.Throwable</exception-type>
						<location>/error/500.jsp</location>
					</error-page> -->
					<error-page>
						<error-code>404</error-code>
						<location>/error/404.jsp</location>
					</error-page>
	
				[ isErrorPage="true | false" ] 如果设置此属性为false, 翻译过来的servlet中将不会含有Exception隐式对象,其中封装的就是上一个页面中抛出的异常信息

				!!![ pageEncoding="characterSet | ISO-8859-1" ] 服务器翻译JSP时使用的编码集.
					如果想防止JSP乱码,应该保证文件的保存编码和JSP翻译成servlet用的编码以及输出到浏览器后浏览器打开的编码一致.此属性一旦设置好,翻译引擎会间接帮我们设置content-type属性.
					
				[ buffer="none | 8kb | sizekb" ] out隐式对象所使用的缓冲区的大小
				[ autoFlush="true | false" ] out隐式对象是否自动刷新缓冲区，默认为true，不需要更改

			-------------------------------------
			2.6.3.include指令
				<%@ include file="" %> -- 可以实现页面包含的效果
				◇ include指令实现的包含叫做静态包含: 
					多个JSP文件翻译成一个servlet, 最终由这一个servlet向外输出数据, 这是源文件级别的包含
				◇ 其他方式的包含叫做动态包含: 
					被包含的页面各自翻译成servlet, 包含的过程其实就是各个servlet分别执行后在输出流上的合并
				◇ 总结: 静态包含在效率上更高一些, 尽量使用静态包含.
			-------------------------------------	
			2.6.4.taglib指令(TODO)
				导入tld标签库文件
				JSTL标签库
				
=================================================
三.JSP的九大隐式对象( 记住!!! )
	javase + javaweb
	servlet生命周期
	JSP的九大隐式对象
	---------------------------------------------
	JSP翻译引擎在将JSP翻译成servlet的过程中, 在servlet里预先定义了九个对象, 因此我们可以在JSP页面中直接使用这九个对象
	Servlet(this)		page
	request				request
	response			response
	ServletConfig		config
	ServletContext		application
	Session				session
						~exception
						~out
						!!pageContext
	
	---------------------------------------------
	~~3.1.out
		相当于response.getWriter();
		区别在于out对象自带缓冲区, 如果out和response.getWriter()混用可能会造成输出顺序上混乱
		
		page指令中buffer和autoflush就是用来设置out缓冲区的
		总结起来一句话, 如果想要在JSP页面中输出内容, 直接使用out, 尽量别使用response.getWriter();

	---------------------------------------------
	!!!3.2.pageContext
		代表当前JSP页面的运行环境的对象, 通过该对象可以访问页面中的共享数据
		PageContext对象功能: 
		-----------------------------------------
		!!!(1) 作为入口对象获取其他八大隐式对象(EL标签)
			getPage()方法		返回page隐式对象
			getRequest()方法	返回request隐式对象 
			getResponse()方法	返回response隐式对象 
			getServletConfig()方法		返回config隐式对象
			getServletContext()方法	返回application隐式对象
			getSession()方法	返回session隐式对象 
			getException()方法	返回exception隐式对象 
			getOut()方法		返回out隐式对象

		-----------------------------------------
		!!!(2) 本身也是一个域对象, 也可以作为入口对象来操作其他三大作用域中的数据
			a)本身是个域对象
				setAttribute(String name, Object obj);
				getAttribute(String name);
				removeAttribute(String name);
				getAttributeNames();

				生命周期: 访问JSP页面开始时创建, 访问JSP页面结束时销毁
				作用范围: 当前JSP页面
				主要功能: 在当前JSP页面中共享数据

			allipcation > Session > request > pageContext
								
			b)作为入口对象, 可以操作其他三大作用域
				setAttribute(String name, Object value,int scope)
				getAttribute(String name,int scope)
				removeAttribute(String name,int scope)

				其中pageContext中代表域的常量：
				PageContext.APPLICATION_SCOPE
				PageContext.SESSION_SCOPE
				PageContext.REQUEST_SCOPE
				PageContext.PAGE_SCOPE 
			
			额外提供了:
				!!findAttribute(String name); //按照由小到大的顺序在四大作用域中搜寻指定名称的属性, 如果找到就返回, 如果都找不到就返回一个null
				
			allipcation > session > request > pageContext
			
		-----------------------------------------
		~~(3) 提供了便捷方法实现请求转发和包含
			request.getRequestDispatcher("/7.jsp").forward(request, response);
			request.getRequestDispatcher("/7.jsp").include(request, response);

			<%@include file="xxx.jsp" %>

			转发: pageContext.forward("/index.jsp"); 
			包含: pageContext.include("/index.jsp");

=================================================
